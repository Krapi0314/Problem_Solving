/*
baekjoon 7576��: �丶��

�ð� ����: 1��
�޸� ����: 256 MB

����
ö���� �丶�� ���忡���� �丶�並 �����ϴ� ū â�� ������ �ִ�. �丶��� �Ʒ��� �׸��� ���� ���� ��� ������ ĭ�� �ϳ��� �־ â�� �����Ѵ�. 
â�� �����Ǵ� �丶��� �߿��� �� ���� �͵� ������, ���� ���� ���� �丶��鵵 ���� �� �ִ�. ���� �� �Ϸ簡 ������, ���� �丶����� ������ ���� �ִ� ���� ���� �丶����� ���� �丶���� ������ �޾� �Ͱ� �ȴ�. �ϳ��� �丶���� ������ ���� ����, ������, ��, �� �� ���⿡ �ִ� �丶�並 �ǹ��Ѵ�. �밢�� ���⿡ �ִ� �丶��鿡�Դ� ������ ���� ���ϸ�, �丶�䰡 ȥ�� ������ �ʹ� ���� ���ٰ� �����Ѵ�. ö���� â�� ������ �丶����� ��ĥ�� ������ �� �Ͱ� �Ǵ���, �� �ּ� �ϼ��� �˰� �;� �Ѵ�.
�丶�並 â�� �����ϴ� ���ڸ���� ���ڵ��� ũ��� ���� �丶���� ���� ���� �丶����� ������ �־����� ��, ��ĥ�� ������ �丶����� ��� �ʹ���, �� �ּ� �ϼ��� ���ϴ� ���α׷��� �ۼ��϶�. ��, ������ �Ϻ� ĭ���� �丶�䰡 ������� ���� ���� �ִ�.

�Է�
ù �ٿ��� ������ ũ�⸦ ��Ÿ���� �� ���� M,N�� �־�����. M�� ������ ���� ĭ�� ��, N�� ������ ���� ĭ�� ���� ��Ÿ����. ��, 2 �� M,N �� 1,000 �̴�. ��° �ٺ��ʹ� �ϳ��� ���ڿ� ����� �丶����� ������ �־�����. ��, ��° �ٺ��� N���� �ٿ��� ���ڿ� ��� �丶���� ������ �־�����. �ϳ��� �ٿ��� ���� �����ٿ� ����ִ� �丶���� ���°� M���� ������ �־�����. ���� 1�� ���� �丶��, ���� 0�� ���� ���� �丶��, ���� -1�� �丶�䰡 ������� ���� ĭ�� ��Ÿ����.
�丶�䰡 �ϳ� �̻� �ִ� ��츸 �Է����� �־�����.

���
�������� �丶�䰡 ��� ���� �������� �ּ� ��¥�� ����ؾ� �Ѵ�. ����, ����� ������ ��� �丶�䰡 �;��ִ� �����̸� 0�� ����ؾ� �ϰ�, �丶�䰡 ��� ������ ���ϴ� ��Ȳ�̸� -1�� ����ؾ� �Ѵ�. 
*/

//#define _CRT_SECURE_NO_WARNINGS

#include <bits/stdc++.h>

using namespace std;

int m, n;
int arr[1000][1000];
bool discovered[1000][1000] = { false, };

int traverse_cnt;
int next_cnt;
int cnt;

int ans;
int num;

int dx[4] = { 1, 0, -1, 0 };
int dy[4] = { 0, 1, 0, -1 };

queue<pair<int, int>> q;

void bfs()
{
	while (!q.empty())
	{
		pair<int, int> here = q.front(); q.pop();
		
		for (int k = 0; k < 4; k++)
		{
			int newy = here.first + dy[k];
			int newx = here.second + dx[k];

			if (newx >= 0 && newx < m && newy >= 0 && newy < n && !discovered[newy][newx] && arr[newy][newx] != -1)
			{
				discovered[newy][newx] = true;
				arr[newy][newx] = 1;
				q.push(make_pair(newy, newx));
				next_cnt++;
			}
		}

		cnt++;
		if (cnt == traverse_cnt)
		{
			ans++;
			traverse_cnt = next_cnt;
			cnt = 0;
			next_cnt = 0;
		}
	}
}

int main(void)
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> m >> n;
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < m; j++)
		{
			cin >> num;
				
			if (num == 1)
			{
				traverse_cnt++;
				q.push(make_pair(i, j)); //ť�� �丶����� ��ġ�� �̸� Ǫ���ؼ� bfs�� ���ÿ� bfs�� �̷�������� �Ѵ�
				discovered[i][j] = true;
			}

			arr[i][j] = num;
		}
	}

	bfs(); //bfs�� ť�� �̸� �丶��(1)���� ��ġ�� �� �����Ƿ�, �Ѳ����� bfs ������ ����


	//��������� 0�� ���������� -> �� ������ �Ұ�
	int flag = 0;
	for (int i = 0; i < n; i++)�� 
	{
		for (int j = 0; j < m; j++)
		{
			if (arr[i][j] == 0)
			{
				flag = 1;
			}
		}
	}

	if (flag == 1)
	{
		cout << "-1";
	}
	else
	{
		cout << ans - 1;
	}
}

/*

!!! �丶�� (1)�� ���� ���� ���� �� �ְ�, �̵��� �Ѳ����� �ֺ� �丶�並 �Ͱ� ����Ƿ�, bfs ���� �� ť�� �̸� ù ������ �丶��(1)���� ��ġ�� ���� ������ �丶��(1)���� bfs�� �����!!!


bfs, �丶�䰡 ��� ���� ������ �ּ� ��¥ ���ϱ�

���� m, ���� n �Է�
�丶�� ���� �Է� �� �迭�� ����
	if 1 �Է�
		traverse_cnt++ (�� �Ͽ� ť���� ���� �����ϴ� �������� ��)

for �迭 ��ȸ�ϸ鼭
	if �� == 1
		bfs

bfs(��ǥ)
	discovered[��ǥ] true
	ť�� Ǫ��

	while(!ť)
		start = ť pop
		for �迭
			if 4���⿡ �����ϰ�, ���� �߰����� ��������
				ť�� Ǫ��
				travsere_cnt++
				
	if traverse 0�� �ƴϸ�
		ans++
 */
